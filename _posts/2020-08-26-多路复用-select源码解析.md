---
layout:     post
title:      "多路复用-select源码解析"
subtitle:   "\"多路复用-select源码解析\""
date:       2020-08-26 20:00:00
author:     "Simon"
catalog: true
header-img: "img/se-1.jpg"
tags:
   - Golang
---

> “Better code, better life. ”

## 多路复用-select源码解析

在介绍`select(2)`之前，我们先看一下什么是IO多路复用（I/O multiplexing），wiki给的解释是这样的：

> **I/O multiplexing**: When an application needs to handle multiple I/O descriptors at the same time, and I/O on any one descriptor can result in blocking. E.g. file and socket descriptors, multiple socket descriptors
>
> IO多路复用：程序可以同时处理多个I/O描述符并且每个描述符都是阻塞的。例如，文件和socket描述符。

操作系统提供了三个系统调用来实现多路复用的功能，分别是`select(2)`、`poll(2)`、`epoll(2)`。其中`select(2)`是最基础的IO多路复用（I/O multiplexing），通常情况下也是性能最差的。通过

```shell
man 2 select
```

我们可以得到其函数原型为

```c
int select(int nfds, 
        fd_set *restrict readfds, 
        fd_set *restrict writefds, 
        fd_set *restrict errorfds, 
        struct timeval *restrict timeout);
```

man中给出的函数说明为：

> select()  and  pselect() allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become "ready" for some class of I/O operation (e.g., input possible).
>
> A file descriptor is considered ready if it is possible to perform a corresponding I/O operation  (e.g.,  read(2)  without blocking, or a sufficiently small write(2)).
>
> select()  和 pselect()可以同时监控多个文件描述符（这里是linux系统性广义的文件描述符），一直到其中一个描述符的状态变为就绪，即可以进行IO操作。

### 从select.c说起

```c
SYSCALL_DEFINE5(select, int, n, 
        fd_set __user *, inp, 
        fd_set __user *, outp, 
        fd_set __user *, exp, 
        struct timeval __user *, tvp)
{
    // …
    ret = core_sys_select(n, inp, outp, exp, to);
    ret = poll_select_copy_remaining(&end_time, tvp, 1, ret);
    return ret;
}


```

