---
layout:     post
title:      "Linux系统寻址过程详解"
subtitle:   "\"Linux系统寻址过程详解\""
date:       2020-11-02 20:00:00
author:     "Simon"
catalog: true
header-img: "img/se-6.jpg"
tags:
   - Linux
---

> “Better code, better life. ”

这几天面了次字节跳动，中间被问到一个问题--“Linux系统下，进程是如何访问内存的？”

当时只说了“虚拟内存，页表，两次寻址，页置换”等内容，但是后续面试官追问的两个问题没有回答的特别好，所以今天准备系统的学习一下这方面内容。

### Linux内存结构

#### 物理内存（Physical Memory）和虚拟内存（Virtual Memory）

Linux系统为了保证进程的隔离性，采用了虚拟内存的设计。每个进程都运行在虚拟内存中，对于一个4G物理内存的操作系统，其每个进程的地址空间都是4G。这块虚拟地址空间包括了程序的堆区、栈区、数据段、代码段、静态变量、全局变量段等等。同时，内存提供了页表这一硬件机制，通过页表，CPU可以把虚拟内存和物理内存一一映射。

CPU通过地址来访问内存中的单元，如果CPU没有MMU，或者有MMU但没有启动，那么CPU内核在取指令或者访问内存时发出的地址(此时必须是物理地址，假如是虚拟地址，那么当前的动作无效)将直接传到CPU芯片的外部地址引脚上，直接被内存芯片(物理内存)接收，这时候的地址就是物理地址。如果CPU启用了MMU(一般是在bootloader中的eboot阶段的进入main()函数的时候启用)，CPU内核发出的地址将被MMU截获，这时候从CPU到MMU的地址称为虚拟地址，而MMU将这个VA翻译成为PA发到CPU芯片的外部地址引脚上，也就是将VA映射到PA中。

MMU将VA映射到PA是以页(page)为单位的，对于32位的CPU，通常一页为4k，物理内存中的一个物理页面称页为一个页框(page frame)。虚拟地址空间划分成称为页（page）的单位,而相应的物理地址空间也被进行划分，单位是页框(frame).页和页框的大小必须相同。

#### TLB缓存

页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据。为了减少因为MMU导致的处理器性能下降，引入了TLB，TLB是Translation Lookaside Buffer的简称，可翻译为“地址转换后援缓冲器”，也可简称为“快表”。简单地说，TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。

TLB中的项由两部分组成：标识和数据。标识中存放的是虚地址的一部分，而数据部分中存放物理页号、存储保护信息以及其他一些辅助信息。虚地址与TLB中项的映射方式有三种：全关联方式、直接映射方式、分组关联方式。

TLB内部存放的基本单位是页表条目，对应着RAM中存放的页表条目。页表条目的大小固定不变的，所以TLB容量越大，所能存放的页表条目越多，TLB hit的几率也越大。但是TLB容量毕竟是有限的，因此RAM页表和TLB页表条目无法做到一一对应。因此CPU收到一个线性地址，那么必须快速做两个判断：

1. 所需的也表示否已经缓存在TLB内部（TLB miss或者TLB hit）
2. 所需的页表在TLB的哪个条目内

为了尽量减少CPU做出这些判断所需的时间，那么就必须在TLB页表条目和内存页表条目之间的对应方式做足功夫

### MMU和缓存

#### 内存管理单元（MMU）

**MMU是硬件设备**，它被保存在主存(main memory)的两级页表中，并且是由协处理器的寄存器1的M位来决定是enabled还是disabled。

MMU的主要作用是负责从CPU内核发出的虚拟地址到物理地址的映射，并提供硬件机制的内存访问权限检查。MMU使得每个用户进程拥有自己的地址空间，并通过内存访问权限的检查保护每个进程所用的内存不被其他进程破坏。

#### 虚拟内存寻址过程

首先将CPU内核发送过来的32位VA[31:0]分成三段，前两段VA[31:20]和VA[19:12]作为两次查表的索引，第三段VA[11:0]作为页内的偏移，查表的步骤如下：

1. 从协处理器CP15的寄存器2(TTB寄存器，translation table base register)中取出保存在其中的第一级页表(translation table)的基地址，这个基地址指的是PA，也就是说页表是直接按照这个地址保存在物理内存中的。
2. 以TTB中的内容为基地址，以VA[31:20]为索引值在一级页表中查找出一项(2^12=4096项)，这个页表项(也称为一个描述符，descriptor)保存着第二级页表(coarse page table)的基地址，这同样是物理地址，也就是说第二级页表也是直接按这个地址存储在物理内存中的。
3. 以VA[19:12]为索引值在第二级页表中查出一项(2^8=256)，这个表项中就保存着物理页面的基地址，我们知道虚拟内存管理是以页为单位的，一个虚拟内存的页映射到一个物理内存的页框，从这里就可以得到印证，因为查表是以页为单位来查的。
4. 有了物理页面的基地址之后，加上VA[11:0]这个偏移量(2^12=4KB)就可以取出相应地址上的数据了。

这个过程称为Translation Table Walk，Walk这个词用得非常形象。从TTB走到一级页表，又走到二级页表，又走到物理页面，一次寻址其实是三次访问物理内存。注意这个“走”的过程完全是硬件做的，每次CPU寻址时MMU就自动完成以上四步，不需要编写指令指示MMU去做，前提是操作系统要维护页表项的正确性，每次分配内存时填写相应的页表项，每次释放内存时清除相应的页表项，在必要的时候分配或释放整个页表。