---
layout:     post
title:      "使用Valgrind调试Linux C++程序"
subtitle:   "\"Valgrind教程\""
date:       2020-08-04 15:00:00
author:     "Simon"
catalog: true
header-img: "img/se-5.jpg"
tags:
   - C++11
---

> “Better code, better life. ”

## 使用Valgrind调试Linux C++程序

C/C++由于足够底层，并且“相信程序员”，所以性能极高，但带来的负面影响就是，这两门语言对程序员要求更高。因为稍不注意，就会有各种底层问题，比如最常见的内存泄漏。

最近发现一个已经上线的服务的内存使用会随着运行时间不断增长，然后稳定在5GB左右，其实内存增长是预期内的，但最后峰值稳定在5GB上下却超过了我的预期。所以准备用Valgrind调试一下程序，本文做个记录。

### Valgrind介绍

`Valgrind`是一个开源工具包，提供了许多调试和分析工具，可以帮助程序员让程序更快、更正确。其中为人熟知的是`Memcheck`，它可以检测许多与内存相关的错误，这些错误在C和c++程序中很常见，可能导致崩溃和不可预测的行为。

其他工具包括：

* **Cachegrind** 
* **Callgrind** 
* **Helgrind** 
* **DRD** 
* **Massif** 
* **DHAT** 
* **BBV** 

还有两个小工具，**Lackey**和**Nulgrind** 。

### 下载&安装

```shell
wget https://sourceware.org/pub/valgrind/valgrind-3.16.1.tar.bz2
tar xf valgrind-3.16.1.tar.bz2
cd valgrind-3.16.1/
./configure
make -j
sudo make install
```

### 基本使用

Valgrind是非侵入式的，你只需要调用Valgrind运行你的程序即可，而不需要重新链接和重新编译。就像这样：

```shell
valgrind [valgrind-options] your-prog [your-prog-options]
```

`valgrind-options`里最重要的的一项是`--tool`(**该选项默认为memcheck**)，它决定你使用`valgrind`工具包中的那一个程序做分析。比如，如果你想看看`ls -l`这个命令执行时耗费的内存，你可以这么做：

```shell
valgrind --tool=memcheck ls -l
```

无论那种工具，Valgrind都是非侵入性的，Valgrind通过读取调试信息获取链接库、执行库，来输出程序运行时状态，并且定位异常代码位置。这体现在，待调试程序会在Valgrind的控制下运行，Valgrind内核会将待调试程序的代码交给所选工具（比如`memcheck`），相应工具会添加一些自己的代码然后运行，将运行结果返回给Valgrind内核。

Valgrind能模拟待调试程序执行的每条指令，所以，所选工具不仅检查或概要分析应用程序中的代码，而且还检查所有支持的动态链接库（包括C库，GUI库等）中的代码。

下面讲使用Valgrind调试要做的一些准备工作。

#### 编译选项

1. 重新编译你的程序，使其附带调试信息（**开启-g选项**）。如果没有调试信息，Valgrind无法定位异常代码位置。
2. 如果待调试的是C++程序，考虑去掉函数内联调用（**开启-fno-inline**），这样可以更简单的查看函数调用堆栈。或者，使用Valgrind选项--read-inline-info = yes可以读取内联函数的调试信息，这样，即便程序使用了内联函数也能正确的显示调用堆栈信息。
3. 关闭编译优化（**-O**）。在`O1`以上的优化级别下，`memcheck`工具会误报一些未初始化值的错误。
4. 使用**-Wall**编译代码，他能识别Valgrind在较高优化级别上可能会遗漏的部分。

#### 输出信息

Valgrind运行中会输出一些文本信息，包括错误报告和其他重要事件。所有行均采用以下格式：

```
==12345== some-message-from-Valgrind
```

其中`12345`是PID。采用这种格式可以吧程序输出可Valgrind输出很好的区分开。默认情况下，Valgrind只输出重要信息，如果需要输出更多细节，可以增加`-v`选项。

Valgrind一些选项来丰富输出路径，包括文件句柄（**--log-fd=9**）、文件（**--log-file=filename**）、socket(**--log-socket=192.168.0.1:12345**)。

#### 异常报告

当错误检查工具检测到程序中发生的不良情况时，错误消息也会被输出。这是Memcheck的示例：

```
==25832== Invalid read of size 4
==25832==    at 0x8048724: BandMatrix::ReSize(int, int, int) (bogon.cpp:45)
==25832==    by 0x80487AF: main (bogon.cpp:66)
==25832==  Address 0xBFFFF74C is not stack'd, malloc'd or free'd
```

以上消息表明该程序对地址`0xBFFFF74C`进行了非法的4字节读取，，该地址不是有效的堆栈地址，也不对应于任何当前堆块或最近释放的堆块。该异常发生在`bogon.cpp`的第45行，从同一文件的第66行调用，依此类推。对于与已标识（当前或已释放）堆块相关的错误，例如读取已释放的内存，Valgrind不仅报告错误发生位置，还有分配/释放的相关的内存块。

Valgrind会记住所有错误报告，并且过滤重复的异常信息，使用`-v`选项可以查看同一个异常发生的次数。

**Valgrind会在相应异常操作发生之前，输出异常信息**。对于`memcheck`，如果你的程序尝试读取0地址，`memcheck`会发出一条相关的异常，然后你的程序才会因为段错误而退出。

#### 错误抑制

错误检查工具可检测操作系统中预装的系统库中的许多问题，例如C库。无法轻松地解决这些问题，因此Valgrind读取了要在启动时消除的错误列表。构建系统时，默认的禁止文件由./configure脚本创建。你可以随意修改并添加到抑制文件，或者更好地编写自己的文件。

### 命令行选项

如上所述，Valgrind的核心接受一组通用选项。每种工具还接受特定的选项。

Valgrind的默认设置在大多数情况下都能成功地提供合理的行为。我们按粗略类别将可用选项分组。

#### 工具选择

```
--tool=<toolname> [default: memcheck]
```

#### 基础选项

```
-v, --verbose
```

提供有关程序各个方面的额外信息，例如：加载的共享对象，使用的抑制，检测和执行引擎的进度以及有关异常行为的警告。重复该选项会增加详细程度。

```
--trace-children=<yes|no> [default: no]
```

启用后，Valgrind将跟踪通过exec系统调用启动的子流程。这对于多进程程序是必需的。

**注意**，Valgrind会追踪到fork出来的子进程（这很难避免，因为fork会复制进程的相同副本），因此此选项的命名可能很差。但是，大多数fork调用的子级仍然会立即调用exec。

```
--child-silent-after-fork=<yes|no> [default: no]
```

启用后，Valgrind将不会显示由fork调用导致的子进程的任何调试或日志记录输出。在处理创建子进程时，这可以使输出的混乱程度降低

```
--vgdb=<no|yes|full> [default: yes]
```

当指定--vgdb = yes或--vgdb = full时，Valgrind将提供“ gdbserver”功能。当程序在Valgrind上运行时，这允许外部GNU GDB调试器控制和调试程序。

```
--track-fds=<yes|no> [default: no]
```

启用后，Valgrind将在退出或请求时通过gdbserver监视命令v.info open_fds打印出打开文件描述符的列表。与每个文件描述符一起打印的是文件打开位置以及与文件描述符有关的任何详细信息（例如文件名或套接字详细信息）的堆栈回溯。

```
--time-stamp=<yes|no> [default: no]
```

启用后，每条消息之前都会显示自启动以来经过的挂钟时间，以天，小时，分钟，秒和毫秒表示。

### Memcheck使用

前文说过，Valgrind是一个多功能的工具包，他有一个内核引擎和很多检测工具。在这些工具中，`memcheck`无疑是最受欢迎的。使用`memcheck`你可以检查如下问题：

* 内存非法访问
* 使用未初始化的变量
* 错误的释放堆内存（比如**double free**）
* 在类似memcpy的函数中重叠了`src`和`dst`指针
* 内存泄漏

诸如此类的问题可能很难通过其他方式发现，通常很长一段时间都未被发现，继而导致偶发性的，难以诊断的崩溃。

#### memcheck的异常信息

Memcheck发出一系列错误消息。本节简要介绍了错误消息的含义。

##### 非法读取/非法写入错误

```
Invalid read of size 4
   at 0x40F6BBCC: (within /usr/lib/libpng.so.2.1.0.9)
   by 0x40F6B804: (within /usr/lib/libpng.so.2.1.0.9)
   by 0x40B07FF4: read_png_image(QImageIO *) (kernel/qpngio.cpp:326)
   by 0x40AC751B: QImageIO::read() (kernel/qimage.cpp:3621)
 Address 0xBFFFF0E0 is not stack'd, malloc'd or free'd
```

当您的程序在Memcheck认为不应该的位置读取或写入内存时，会发生这种情况。

在此示例中，程序在系统提供的库libpng.so.2.1.0.9中某个位置的地址0xBFFFF0E0处进行了4字节读取，该库是从同一个库中的其他位置（从qpngio.cpp的第326行调用）调用的， 等等。

##### 使用未初始化的值

```
Conditional jump or move depends on uninitialised value(s)
   at 0x402DFA94: _IO_vfprintf (_itoa.h:49)
   by 0x402E8476: _IO_printf (printf.c:36)
   by 0x8048472: main (tests/manuel1.c:8)
```

当您的程序使用尚未初始化的值（换句话说，未定义）时，会报告未初始化值的使用错误。在这里，未定义的值在C库的printf机械内部的某处使用。运行以下小程序时，报告了此错误。

##### 在系统调用中使用未初始化或无法寻址的值

Memcheck检查系统调用的所有参数：

* 是否已初始化。
* 检查整个缓冲区是否可寻址，并且其内容已初始化。
* 如果系统调用需要写入用户提供的缓冲区，则Memcheck会检查缓冲区是否可寻址。

##### 非法free内存

```
Invalid free()
   at 0x4004FFDF: free (vg_clientmalloc.c:577)
   by 0x80484C7: main (tests/doublefree.c:10)
 Address 0x3807F7B4 is 0 bytes inside a block of size 177 free'd
   at 0x4004FFDF: free (vg_clientmalloc.c:577)
   by 0x80484C7: main (tests/doublefree.c:10)
```

Memcheck使用malloc / new跟踪程序分配的块，因此它可以准确知道free / delete的参数是否合法。在这里，此测试程序已释放相同的块两次。与非法的读/写错误一样，Memcheck尝试使释放的地址有意义。

##### 使用不合适的释放函数释放堆块时

```
Mismatched free() / delete / delete []
   at 0x40043249: free (vg_clientfuncs.c:171)
   by 0x4102BB4E: QGArray::~QGArray(void) (tools/qgarray.cpp:149)
   by 0x4C261C41: PptDoc::~PptDoc(void) (include/qmemarray.h:60)
   by 0x4C261F0E: PptXml::~PptXml(void) (pptxml.cc:44)
 Address 0x4BB292A8 is 0 bytes inside a block of size 64 alloc'd
   at 0x4004318C: operator new[](unsigned int) (vg_clientfuncs.c:152)
   by 0x4C21BC15: KLaola::readSBStream(int) const (klaola.cc:314)
   by 0x4C21C155: KLaola::stream(KLaola::OLENode const *) (klaola.cc:416)
   by 0x4C21788F: OLEFilter::convert(QCString const &) (olefilter.cc:272)
```

`memcheck`会检查堆内存的分配和释放是否一致。如果你是由**`malloc`, `calloc`, `realloc`, `valloc` 或者 `memalign`**分配的内存，必须使用**`free`**来释放；使用**`new`**分配的内存，必须使用**`delete`**来释放；使用**`new[]`**分配的内存，必须使用**`delete[]`**来释放。

##### 重叠的源块和目标块

以下C库函数将一些数据从一个存储块复制到另一个（或类似的存储块）：memcpy，strcpy，strncpy，strcat，strncat。不允许它们的src和dst指针指向的块重叠。 POSIX标准的措辞大致如下：“如果在重叠的对象之间进行复制，则行为未定义。”因此，Memcheck对此进行检查。

##### 内存泄漏

Memcheck跟踪响应于对malloc / new等的调用而发出的所有堆块。因此，当程序退出时，它知道哪些块尚未释放。 如果正确设置了--leak-check，则对于每个剩余的块，Memcheck会根据根集中的指针确定该块是否可访问。

在Memcheck官方手册上，列出了以下九种内存泄露的情况：

```
     Pointer chain            AAA Leak Case   BBB Leak Case
     -------------            -------------   -------------
(1)  RRR ------------> BBB                    DR
(2)  RRR ---> AAA ---> BBB    DR              IR
(3)  RRR               BBB                    DL
(4)  RRR      AAA ---> BBB    DL              IL
(5)  RRR ------?-----> BBB                    (y)DR, (n)DL
(6)  RRR ---> AAA -?-> BBB    DR              (y)IR, (n)DL
(7)  RRR -?-> AAA ---> BBB    (y)DR, (n)DL    (y)IR, (n)IL
(8)  RRR -?-> AAA -?-> BBB    (y)DR, (n)DL    (y,y)IR, (n,y)IL, (_,n)DL
(9)  RRR      AAA -?-> BBB    DL              (y)IL, (n)DL

Pointer chain legend:
- RRR: a root set node or DR block
- AAA, BBB: heap blocks
- --->: a start-pointer
- -?->: an interior-pointer

Leak Case legend:
- DR: Directly reachable
- IR: Indirectly reachable
- DL: Directly lost
- IL: Indirectly lost
- (y)XY: it's XY if the interior-pointer is a real pointer
- (n)XY: it's XY if the interior-pointer is not a real pointer
- (_)XY: it's XY in either case
```

