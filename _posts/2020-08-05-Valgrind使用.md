---
layout:     post
title:      "使用Valgrind调试Linux C++程序"
subtitle:   "\"Valgrind教程\""
date:       2020-08-04 15:00:00
author:     "Simon"
catalog: true
header-img: "img/se-5.jpg"
tags:
   - C++11
---

> “Better code, better life. ”

## 使用Valgrind调试Linux C++程序

C/C++由于足够底层，并且“相信程序员”，所以性能极高，但带来的负面影响就是，这两门语言对程序员要求更高。因为稍不注意，就会有各种底层问题，比如最常见的内存泄漏。

最近发现一个已经上线的服务的内存使用会随着运行时间不断增长，然后稳定在5GB左右，其实内存增长是预期内的，但最后峰值稳定在5GB上下却超过了我的预期。所以准备用Valgrind调试一下程序，本文做个记录。

### Valgrind介绍

`Valgrind`是一个开源工具包，提供了许多调试和分析工具，可以帮助程序员让程序更快、更正确。其中为人熟知的是`Memcheck`，它可以检测许多与内存相关的错误，这些错误在C和c++程序中很常见，可能导致崩溃和不可预测的行为。

其他工具包括：

* **Cachegrind** 
* **Callgrind** 
* **Helgrind** 
* **DRD** 
* **Massif** 
* **DHAT** 
* **BBV** 

还有两个小工具，**Lackey**和**Nulgrind** 。

### 下载&安装

```shell
wget https://sourceware.org/pub/valgrind/valgrind-3.16.1.tar.bz2
tar xf valgrind-3.16.1.tar.bz2
cd valgrind-3.16.1/
./configure
make -j
sudo make install
```

### 基本使用

Valgrind是非侵入式的，你只需要调用Valgrind运行你的程序即可，而不需要重新链接和重新编译。就像这样：

```shell
valgrind [valgrind-options] your-prog [your-prog-options]
```

`valgrind-options`里最重要的的一项是`--tool`(**该选项默认为memcheck**)，它决定你使用`valgrind`工具包中的那一个程序做分析。比如，如果你想看看`ls -l`这个命令执行时耗费的内存，你可以这么做：

```shell
valgrind --tool=memcheck ls -l
```

无论那种工具，Valgrind都是非侵入性的，Valgrind通过读取调试信息获取链接库、执行库，来输出程序运行时状态，并且定位异常代码位置。这体现在，待调试程序会在Valgrind的控制下运行，Valgrind内核会将待调试程序的代码交给所选工具（比如`memcheck`），相应工具会添加一些自己的代码然后运行，将运行结果返回给Valgrind内核。

Valgrind能模拟待调试程序执行的每条指令，所以，所选工具不仅检查或概要分析应用程序中的代码，而且还检查所有支持的动态链接库（包括C库，GUI库等）中的代码。

下面讲使用Valgrind调试要做的一些准备工作。

#### 编译选项

1. 重新编译你的程序，使其附带调试信息（**开启-g选项**）。如果没有调试信息，Valgrind无法定位异常代码位置。
2. 如果待调试的是C++程序，考虑去掉函数内联调用（**开启-fno-inline**），这样可以更简单的查看函数调用堆栈。或者，使用Valgrind选项--read-inline-info = yes可以读取内联函数的调试信息，这样，即便程序使用了内联函数也能正确的显示调用堆栈信息。
3. 关闭编译优化（**-O**）。在`O1`以上的优化级别下，`memcheck`工具会误报一些未初始化值的错误。
4. 使用**-Wall**编译代码，他能识别Valgrind在较高优化级别上可能会遗漏的部分。

#### 输出信息

Valgrind运行中会输出一些文本信息，包括错误报告和其他重要事件。所有行均采用以下格式：

```
==12345== some-message-from-Valgrind
```

其中`12345`是PID。采用这种格式可以吧程序输出可Valgrind输出很好的区分开。默认情况下，Valgrind只输出重要信息，如果需要输出更多细节，可以增加`-v`选项。

Valgrind一些选项来丰富输出路径，包括文件句柄（**--log-fd=9**）、文件（**--log-file=filename**）、socket(**--log-socket=192.168.0.1:12345**)。

#### 异常报告

当错误检查工具检测到程序中发生的不良情况时，错误消息也会被输出。这是Memcheck的示例：

```
==25832== Invalid read of size 4
==25832==    at 0x8048724: BandMatrix::ReSize(int, int, int) (bogon.cpp:45)
==25832==    by 0x80487AF: main (bogon.cpp:66)
==25832==  Address 0xBFFFF74C is not stack'd, malloc'd or free'd
```

以上消息表明该程序对地址`0xBFFFF74C`进行了非法的4字节读取，，该地址不是有效的堆栈地址，也不对应于任何当前堆块或最近释放的堆块。该异常发生在`bogon.cpp`的第45行，从同一文件的第66行调用，依此类推。对于与已标识（当前或已释放）堆块相关的错误，例如读取已释放的内存，Valgrind不仅报告错误发生位置，还有分配/释放的相关的内存块。

Valgrind会记住所有错误报告，并且过滤重复的异常信息，使用`-v`选项可以查看同一个异常发生的次数。

**Valgrind会在相应异常操作发生之前，输出异常信息**。对于`memcheck`，如果你的程序尝试读取0地址，`memcheck`会发出一条相关的异常，然后你的程序才会因为段错误而退出。

#### 错误抑制

错误检查工具可检测操作系统中预装的系统库中的许多问题，例如C库。无法轻松地解决这些问题，因此Valgrind读取了要在启动时消除的错误列表。构建系统时，默认的禁止文件由./configure脚本创建。你可以随意修改并添加到抑制文件，或者更好地编写自己的文件。

### 命令行选项



