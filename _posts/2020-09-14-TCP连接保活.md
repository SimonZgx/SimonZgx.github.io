---
layout:     post
title:      "TCP连接保活"
subtitle:   "\"TCP连接保活\""
date:       2020-09-14 20:00:00
author:     "Simon"
catalog: true
header-img: "img/se-6.jpg"
tags:
   - C++
---

> “Better code, better life. ”

## TCP连接保活

> 对于一个TCP长连接的保活又两种方式，一种在应用层发心跳包，一种是在传输层，通过SO_Keeplive实现。

### 保活的必要性

现在的网络编程大多使用长连接，对于一个TCP长连接，服务端为维持每一个客户端的连接都需要一定的资源，这就需要服务端每隔一段时间将不活跃的连接剔除调，这样就面临下面两问题：

1. 如何判断对方是否还在线。TCP对于非正常断开的连接系统并不能侦测到（比如网线断掉）。
2. 长时间没有任何数据发送，连接可能会被中断。这是因为，网络连接中间可能会经过路由器、防火墙等设备，而这些有可能会对长时间没有活动的连接断掉。

基于上面两点考虑，需要保活机制。

### 传输层的保活

传输层的保活需要通过`setsockopt`函数来完成，其函数原型为：

```c
int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);
```

一般情况下，设置TCP连接的保活代码为：

```
int val = 1;
if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1) {
    NetSetError(err_msg, "setsockopt SO_KEEPALIVE: %s", strerror(errno));
    return NET_ERR;
}

val = interval;
if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
    NetSetError(err_msg, "setsockopt TCP_KEEPIDLE: %s\n", strerror(errno));
    return NET_ERR;
}

val = interval / 3;
if (val == 0)val = 1;
if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {
    NetSetError(err_msg, "setsockopt TCP_KEEPIDLE: %s\n", strerror(errno));
    return NET_ERR;
}

val = 3;
if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {
    NetSetError(err_msg, "setsockopt TCP_KEEPCNT: %s\n", strerror(errno));
    return NET_ERR;
}
```

我们从上到下依次解释。

```c
int val = 1;
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val))
```

这两行等于打开了`SO_KEEPALIVE`保活选项，