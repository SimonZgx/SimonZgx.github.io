---
layout:     post
title:      "再见了函数指针"
subtitle:   " \"c++11 std::bind 和 std::function介绍\""
date:       2020-05-27 23:00:00
author:     "Simon"
catalog: true
tags:
    - C++11

---

> “Better code, better life. ”

# 再见了函数指针！

在C语言中，如果想实现回调函数之类功能，函数指针大概是不能避免的。但是，凡是涉及到**指针**的东西，都很危险！由于C语言中，指针只是一个地址，两个任何类型的指针可以通过**void***来互相转换，**并且可以通过编译！！**所以在大型程序中，经常出现一个指针被多次**cast**后得到了一个非预期类型，导致程序崩溃。到了C++，新标准增加了`std::bind`和`std::function`两个模板方法，可以做到对回调函数/函数指针的完全替代。

### std::bind

`bind`是一个模板方法，其原型为

```c++
template<typename _Func, typename... _Args>
inline typename
_Bind_helper<Type T, _Func, _Args...>::type
bind(_Func&& __f, _BoundArgs&&... __args){
    typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
    return typename __helper_type::type(std::forward<_Func>(__f),
                                        std::forward<_BoundArgs>(__args)...);
}

template<bool _SocketLike, typename _Func, typename... _BoundArgs>
struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
        typedef typename decay<_Func>::type __func_type;
        typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };

template<typename _Tp>
class decay
{
    typedef typename remove_reference<_Tp>::type __remove_type;

    public:
    typedef typename __decay_selector<__remove_type>::__type type;
};
```

这里直接粘贴了部分化简后的关键源码，其中一些函数没有很细致的看，但是只看这个声明，我们可以发现：

* bind第一个模板参数是一个`callable`的对象，它可以是函数或者重载了`()`操作符的类；第二个是一个可变模板参数，它应该是第一个`callable`对象的参数。
* bind返回一个`_BIND`类型，即`_Bind_helper<Type T, _Func, _Args...>::type`。
* bind的两个形参都具有`&&`万能引用型别。
* bind在底层其实对`_Func`和`_Args`做了`remove_reference`处理的，这里其实有坑，后面会讲。

### std::placeholder

通过bind，我们可以获得一个`callable`的对象，通过`()`可以执行并获取结果，举个例子：

```c++
#include <iostream>
#include <functional>

using namespace std;

void add(int x, int y) {
    cout << x + y << endl;
}

int main(){
    auto f = bind(add, 4, 5);
    f();
}
```

output:

```c++
9
```

在这里bind的作用其实和lambda表达式类似，它创造了一个可以在未来执行的并获取结果的函数。上面的例子中，在bind的时候就已经确定了传递的参数，但实际上，借助`std::placeholder`我们可以实现调用时传参。同样的例子，稍作修改：

```c++
int main(){
    auto f = bind(add, 4, std::placeholders::_1);
    f(5);
}
```

output:

```c++
9
```

